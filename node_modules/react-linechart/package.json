{
  "_args": [
    [
      {
        "raw": "react-linechart",
        "scope": null,
        "escapedName": "react-linechart",
        "name": "react-linechart",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\Frullo\\Documents\\btc"
    ]
  ],
  "_from": "react-linechart@latest",
  "_id": "react-linechart@1.1.12",
  "_inCache": true,
  "_location": "/react-linechart",
  "_nodeVersion": "6.11.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-linechart-1.1.12.tgz_1503464927183_0.39085483900271356"
  },
  "_npmUser": {
    "name": "rafaelquintanilha",
    "email": "rafaelquintanilha@poli.ufrj.br"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-linechart",
    "scope": null,
    "escapedName": "react-linechart",
    "name": "react-linechart",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-linechart/-/react-linechart-1.1.12.tgz",
  "_shasum": "d33ff7444c3501312edae4d7493b2ef7072c8a12",
  "_shrinkwrap": null,
  "_spec": "react-linechart",
  "_where": "C:\\Users\\Frullo\\Documents\\btc",
  "author": {
    "name": "Rafael Quintanilha"
  },
  "bugs": {
    "url": "https://github.com/rafaelquintanilha/react-linechart/issues"
  },
  "dependencies": {
    "d3": "3.5.17",
    "prop-types": "15.5.10"
  },
  "description": "Highly customizable line chart with React",
  "devDependencies": {
    "babel-cli": "6.5.1",
    "babel-core": "6.10.4",
    "babel-eslint": "5.0.0",
    "babel-loader": "6.2.3",
    "babel-plugin-react-display-name": "2.0.0",
    "babel-preset-es2015": "6.5.0",
    "babel-preset-react": "6.5.0",
    "babel-preset-react-hmre": "1.1.1",
    "babel-preset-stage-1": "6.5.0",
    "browser-sync": "2.11.1",
    "chai": "3.4.1",
    "cheerio": "0.19.0",
    "colors": "1.1.2",
    "cross-env": "1.0.7",
    "css-loader": "0.23.1",
    "eslint": "2.2.0",
    "eslint-loader": "1.3.0",
    "eslint-plugin-react": "4.0.0",
    "extract-text-webpack-plugin": "1.0.1",
    "file-loader": "0.8.5",
    "ignore-styles": "1.2.0",
    "mocha": "2.3.4",
    "node-sass": "3.4.2",
    "npm-run-all": "1.6.0",
    "object-assign": "4.1.0",
    "react": "15.1.0",
    "redbox-react": "1.2.6",
    "rimraf": "2.5.0",
    "sass-loader": "3.1.2",
    "style-loader": "0.13.0",
    "webpack": "1.13.1",
    "webpack-dev-middleware": "1.4.0",
    "webpack-hot-middleware": "2.6.0",
    "yargs": "3.32.0"
  },
  "directories": {},
  "dist": {
    "shasum": "d33ff7444c3501312edae4d7493b2ef7072c8a12",
    "tarball": "https://registry.npmjs.org/react-linechart/-/react-linechart-1.1.12.tgz"
  },
  "gitHead": "06a886eba95ad79c19c5db9b795d8cd5008de548",
  "homepage": "https://github.com/rafaelquintanilha/react-linechart#readme",
  "keywords:": [
    "react",
    "reactjs",
    "react-router",
    "d3",
    "linechart",
    "line-chart",
    "chart"
  ],
  "license": "MIT",
  "main": "dist/bundle.js",
  "maintainers": [
    {
      "name": "rafaelquintanilha",
      "email": "rafaelquintanilha@poli.ufrj.br"
    }
  ],
  "name": "react-linechart",
  "optionalDependencies": {},
  "readme": "React Linechart\n===============\n\nHighly customizable line charts using React! Check the [Live Demo](http://rafaelquintanilha.com/apps/linechart/) and follow along the [tutorial](http://rafaelquintanilha.com/introducing-react-line-chart/).\n\n1. [Why](#why)\n2. [Installation](#installation)\n3. [Usage](#usage)\n4. [Properties Table](#properties-table)\n5. [Tooltips](#tooltips)\n6. [Derived Charts](#derived-charts)\n7. [Parsers](#parsers)\n8. [isDate](#isdate)\n9. [Improvements](#improvements)\n\n## Why\nI always felt frustrated with the libraries out there which aim to implement this simple visualization. Many would lack basic features (such as adding multi lines or changing line colors) or would be extremely low-level (think d3). Built on top of d3, `react-linechart` provides necessary customization without losing simplicity.\n\n## Installation\n```javascript\nnpm install react-linechart --save\n```\n\n## Usage\n\nAdd Line Charts with minimum configuration:\n\n```javascript\nimport React, { Component } from 'react';\nimport LineChart from 'react-linechart';\nimport '../node_modules/react-linechart/dist/styles.css';\n\nexport default class App extends Component {\n\trender() {\n\t\tconst data = [\n\t\t\t{\t\t\t\t\t\t\t\t\t\n\t\t\t\tcolor: \"steelblue\", \n\t\t\t\tpoints: [{x: 1, y: 2}, {x: 3, y: 5}, {x: 7, y: -3}] \n\t\t\t}\n\t\t];\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<div className=\"App\">\n\t\t\t\t\t<h1>My First LineChart</h1>\n\t\t\t\t\t<LineChart \n\t\t\t\t\t\twidth={600}\n\t\t\t\t\t\theight={400}\n\t\t\t\t\t\tdata={data}\n\t\t\t\t\t/>\n\t\t\t\t</div>\t\t\t\t\n\t\t\t</div>\n\t\t);\n\t}\n}\n```\n\nThis component is an attempt to simplify the rendering of a basic Line Chart by exposing many props that are commonly used. I realize it is very hard to encompass every use case, so I put an effort in making this especially pleasant to work with continuous values of numbers and dates.\n\nThe only mandatory prop is `data` - an array of objects describing the lines that will be rendered on screen. The typical line object follows this structure:\n\n```javascript\n{\n\tid,\n\tname,\n\tcolor,\n\tpoints: [ { x, y } ]\n}\n```\n\nWhere `id` is an identificator for the line, `name` is a name for the line, `color` is a color for the line and `points` are an array of `{ x, y }` objects representing the data. It would be particularly annoying if we need to parse our data to this format, so I provided a [handful of parser functions](#parsers) that hopefully will meet most data formats commonly out there.\n\n## Properties Table\n\nProperty | Type | Default | Description\n--- | --- | --- | ---\nid | `String` | none | Unique ID for the visualization\ndata | `Array<Object>` | none | Data that describes lines to be rendered (required)\nwidth | `Number|String` | `1024` | Chart width \nheight | `Number|String` | `720` | Chart height\nmargins | `Object` | `{ top: 50, right: 20, bottom: 50, left: 55 }` | Chart margins\nxLabel | `String` | `\"X\"` | Label for the X axis\nyLabel | `String` | `\"Y\"` | Label for the Y axis\nhideXLabel | `Bool` | `false` | States if the X label is hidden\nhideYLabel | `Bool` | `false` | States if the Y label is hidden\nhideXAxis | `Bool` | `false` | States if the X axis is hidden\nhideYAxis | `Bool` | `false` | States if the Y axis is hidden\nxMin | `String` | none | Lower domain for the X axis\nxMax | `String` | none | Higher domain for the X axis\nyMin | `String` | none | Lower domain for the Y axis\nyMax | `String` | none | Higher domain for the Y axis\nisDate | `Bool` | `false` | Determines if we need to treat the X dimension as date (or numeric)\nxParser | `Function` | `isDate ? d3.time.format(\"%Y-%m-%d\").parse : ((x) => x)` | Parse X values before scaling\nxDisplay | `Function` | `isDate ? d3.time.format(\"%b %d\") : d3.format(\"d\") ` | Parse X values before displaying\nticks | `Number` | `10` | Chart width. \nhideLines | `Bool` | `false` | States if lines are drawn\ninterpolate | `String` | `\"cardinal\"` | Line interpolation function\nhidePoints | `Bool` | `false` | States if points are shown\npointRadius | `Number` | `5` | Point radius in pixels\nonPointClick | `Function` | `(event, point) => console.log(point)` | Callback for clicking on points\nonPointHover | `Function` | none | Callback for hovering on points\nonTextClick | `Function` | `(text) => console.log(text)` | Callback for clicking on texts\nonTextHover | `Function` | none | Callback for hovering on texts\nshowLegends | `Bool` | `false` | States if legends are shown\nlegendPosition | `String` | `\"top-left\"` | Position where the legend is rendered\ntooltipClass | `String` | `\"svg-line-chart-tooltip\"` | Tooltip class\npointClass | `String` | `\"svg-line-chart-point\"` | Point class\nlabelClass | `String` | `\"svg-line-chart-label\"` | Label class\n\n## Tooltips\n\nIt is easy to hook tooltips onto your chart. Just provide a function on the `onPointHover` prop that returns a HTML element and this will be displayed inside the tooltip. You can use the class provided by default or write your own and pass to the chart as a `tooltipClass` prop.\n\n## Derived Charts\n\nTurns out a simple Line Chart with the right props can assume a different aspect. For example, setting `hideLines={true}` gives an awesome Scatter Plot. \n\n```javascript\nimport { ScatterPlot } from 'react-linechart'\n...\nrender() {\n\treturn <ScatterPlot id=\"my-scatter-plot\" data={data} />\n}\n```\n\nIt is also possible to build a \"Stair Chart\", which is how I am calling a time-table-ish kind of chart when we have start and end dates and want to display them as nice stacked bars. Check the [Live Demo](http://rafaelquintanilha.com/apps/linechart/) to get a better insight.\n\n```javascript\nimport { StairChart } from 'react-linechart'\n...\nrender() {\n\treturn <StairChart id=\"my-stair-chart\" data={stairedData} />\n}\n```\n\nYou can add optional `onTextHover` and `onTextClick` functions to interact with the chart.\n\n## Parsers\n\nIn order to comply with the format specified, you can use 3 utilitaries functions which parse your raw data. They are the following:\n\n##### parseFlatArray(data, xDimension, yDimensionArray, colorArray, idArray, nameArray)\n\nParameter | Type | Default | Description\n--- | --- | --- | ---\ndata | `Array<Objects>` | none | Array of objects describing your data in a flat format\nxDimensions | `String` | none | Property that will serve as X dimension\nyDimensionArray | `Array<Strings>` | none | Array of properties that will serve as Y dimension\ncolorArray | `Array<Strings>` | `[]` | Array of hex strings colors that will be assigned in accordance with the yDimensionArray. If no colors are specified, a default array of 20 colors is used\nidArray | `Array<Strings>` | `[]` | Array of ids that will be assigned in accordance with yDimensionArray. If no ids are specified, a combination of X and Y dimensions is used \nnameArray | `Array<Strings>` | `[]` | Array of names that will be assigned in accordance with yDimensionArray\n\nThis is useful when you want to display a multi-line chart in a one-data-per-object basis. Just pick the dimensions you want and the chart will be rendered.\n\n```javascript\nconst gsmData = [\n\t{\n\t\t\"Year\": 1880,\n\t\t\"Glob\": -19,\n\t\t\"NHem\": -33,\n\t\t\"SHem\": -5,\t\t\n\t},\n\t{\n\t\t\"Year\": 1881,\n\t\t\"Glob\": -10,\n\t\t\"NHem\": -18,\n\t\t\"SHem\": -2,\n\t},\n\t...\n];\n\n// Creates a three-line chart: Glob x Year, Glob x NHem, Glob x SHem\nconst gsmFlat = parseFlatArray(gsmData, \"Year\", [\"Glob\", \"NHem\", \"SHem\"]);\n```\n\n##### parseGroupingBy(data, xDimension, yDimension, groupByDimension, nameGenerator, colorArray, idArray)\n\nParameter | Type | Default | Description\n--- | --- | --- | ---\ndata | `Array<Objects>` | none | Array of objects describing your data in an indexed format\nxDimensions | `String` | none | Property that will serve as X dimension\nyDimension | `String` | none | Property that will serve as Y dimension\ngroupByDimension | `String` | none | Dimension that will be group lines together\nnameGenerator | `Function` | ```nameGenerator : (i) => `Grouped by ${groupByDimension} = ${i}`;``` | Function that will generate a name based on the groupByDimension value\ncolorArray | `Array<Strings>` | `[]` | Array of hex strings colors that will be assigned in accordance with the yDimensionArray. If no colors are specified, a default array of 20 colors is used\nidArray | `Array<Strings>` | `[]` | Array of ids that will be assigned in accordance with yDimensionArray. If no ids are specified, a combination of X and Y dimensions is used \n\nThis is useful when you want to aggregate data based on some dimension, an id, for example.\n\n```javascript\nconst data = [\n\t{ id: 1, value: 3, date: \"2016-01-01\" },\n\t{ id: 1, value: 4, date: \"2016-01-03\" },\n\t{ id: 2, value: 10, date: \"2016-01-02\" },\n\t{ id: 1, value: 6, date: \"2016-01-04\" },\n\t{ id: 2, value: 13, date: \"2016-01-06\" },\n\t{ id: 1, value: 5, date: \"2016-01-08\" },\n\t{ id: 2, value: 10, date: \"2016-03-20\" }\n];\n\nconst grouped = parseGroupingBy(data, \"date\", \"value\", \"id\");\n```\n\n##### parseStairChart(data, start, end, name, color)\nParameter | Type | Default | Description\n--- | --- | --- | ---\ndata | `Array<Objects>` | none | Array of objects describing your data\nstart | `String` | none | Property that will serve as start date\nend | `String` | none | Property that will serve as end date\nname | `String` | none | Property that will serve as name for the given line\ncolor | `String` | `\"steelblue\"` | Color to fill the line\n\nThis is useful when you want to display a kind of time frame.\n\n```javascript\nconst stair = [\n\t{ startDate: \"2016-01-01\", endDate: \"2016-01-04\", name: \"Task 1\" },\n\t{ startDate: \"2016-01-02\", endDate: \"2016-01-03\", name: \"Task 2\" },\n\t{ startDate: \"2016-01-03\", endDate: \"2016-01-06\", name: \"Task 3\" },\n\t{ startDate: \"2016-01-05\", endDate: \"2016-01-10\", name: \"Task 4\" },\n\t{ startDate: \"2016-01-08\", endDate: \"2016-01-13\", name: \"Task 5\" },\n\t{ startDate: \"2016-01-09\", endDate: \"2016-01-20\", name: \"Task 6\" }\n];\nconst staired = parseStairChart(stair, \"startDate\", \"endDate\", \"name\");\n```\n\n## isDate\n\nThe component has a shortcut `isDate` property which will try to parse your `x` input as a Date. If you use a numeric value and pass `isDate={true}`, then unexpected behaviour will happen (same for the reverse). This is supposed to be helpful considering standard scenarios but you can always use the `xParser` prop to parse whatever data you have to a numeric value and the `xDisplay` prop to display whatever numeric value you have to something more meaningful to your visualization.\n\nMeanwhile, by default the component will first parse the date in a `\"YYYY-MM-DD\"` format in a `Date` object. By default I'm using `d3` functions, but you can write your own or use another Date parser such as [MomentJS](http://momentjs.com).\n\n## Improvements\n\nThis is a work in progress, so *expect* things to break. You can fork your own version or, better still, contribute for the completeness of this library. Help me making a great tool! :)",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rafaelquintanilha/react-linechart.git"
  },
  "scripts": {
    "build": "npm-run-all --parallel test build:js",
    "build:js": "babel-node tools/build.js ",
    "clean-dist": "npm run remove-dist && mkdir dist",
    "lint:tools": "eslint webpack.config.js tools",
    "open:src": "babel-node tools/srcServer.js",
    "prebuild": "npm run clean-dist",
    "prestart": "npm run remove-dist",
    "remove-dist": "rimraf ./dist",
    "start": "npm-run-all --parallel lint:tools test:watch open:src",
    "test": "cross-env NODE_ENV=test mocha --reporter progress --compilers js:babel-core/register --recursive \"./src/**/*.spec.js\" --require ignore-styles",
    "test:watch": "npm run test -- --watch"
  },
  "version": "1.1.12"
}
